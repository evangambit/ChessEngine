#ifndef MOVEGEN_H
#define MOVEGEN_H

#include "Position.h"
#include "slide_lookup.h"

namespace ChessEngine {

namespace diag {

// For a given square, get all points along its southwest/northeast diagonal.
constexpr Bitboard kSouthWestDiagonalMask[64] = {
  0x1,
  0x102,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x102,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x4080000000000000,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x4080000000000000,
  0x8000000000000000,
};

constexpr Bitboard kMainDiagonals = 0x8040201008040201 | 0x102040810204080;

// For a given square, get all points along its southeast/northwest diagonal.
constexpr Bitboard kSouthEastDiagonalMask[64] = {
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x8040,
  0x80,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x8040,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x201000000000000,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x100000000000000,
  0x201000000000000,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
};

const uint64_t kSouthEastShift[64] = {
  0, 1, 2, 3, 4, 5, 6, 7,
  0, 0, 1, 2, 3, 4, 5, 6,
  0, 0, 0, 1, 2, 3, 4, 5,
  0, 0, 0, 0, 1, 2, 3, 4,
  0, 0, 0, 0, 0, 1, 2, 3,
  0, 0, 0, 0, 0, 0, 1, 2,
  0, 0, 0, 0, 0, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
};

const uint64_t kSouthWestShift[64] = {
  7, 6, 5, 4, 3, 2, 1, 0,
  6, 5, 4, 3, 2, 1, 0, 0,
  5, 4, 3, 2, 1, 0, 0, 0,
  4, 3, 2, 1, 0, 0, 0, 0,
  3, 2, 1, 0, 0, 0, 0, 0,
  2, 1, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
};

// After calling "southeast_diag_to_byte", this array indicates
// which bits in the byte are off the board (and hence invalid to move to).
// Generated by
//
// for (int i = 0; i < 64; ++i) {
//   uint8_t byte = ~diag::southeast_diag_to_byte(Square(i), kUniverse);
//   std::cout << "0x" << std::hex << unsigned(byte) << ", ";
//   if (i % 8 == 7) {
//     std::cout << std::endl;
//   }
// }
const uint8_t kSouthEastOffBoard[64] = {
  0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe,
  0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc,
  0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8,
  0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0,
  0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0,
  0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0,
  0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80,
  0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0,
};

const uint8_t kSouthWestOffBoard[64] = {
  0x7f, 0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0,
  0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0, 0x1,
  0x1f, 0xf, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3,
  0xf, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7,
  0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xf,
  0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f,
  0x1, 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f,
  0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f,
};

constexpr Bitboard kBishopMagic = bb(56) | bb(48) | bb(40) | bb(32) | bb(24) | bb(16) | bb(8) | bb(0);

uint8_t southeast_diag_to_byte(Square sq, Bitboard b) {
  b &= kSouthEastDiagonalMask[sq];
  b >>= kSouthEastShift[sq];
  return (b * kBishopMagic) >> 56;
}

uint8_t southwest_diag_to_byte(Square sq, Bitboard b) {
  b &= kSouthWestDiagonalMask[sq];
  b <<= kSouthWestShift[sq];
  return (b * kBishopMagic) >> 56;
}

Bitboard byte_to_southeast_diag(Square sq, Bitboard byte) {
  assert(byte < 256);
  byte *= kBishopMagic;
  byte <<= diag::kSouthEastShift[sq];
  byte &= kSouthEastDiagonalMask[sq];
  return byte;
}

Bitboard byte_to_southwest_diag(Square sq, Bitboard byte) {
  assert(byte < 256);
  byte *= kBishopMagic;
  byte >>= diag::kSouthWestShift[sq];
  byte &= kSouthWestDiagonalMask[sq];
  return byte;
}

}  // namespace diag

// Rotates east-most file to south-most rank.
constexpr Bitboard kRookMagic = bb(49) | bb(42) | bb(35) | bb(28) | bb(21) | bb(14) | bb(7) | bb(0);

uint8_t sliding_moves(uint8_t loc, uint8_t friends, uint8_t enemies) {
  assert(std::popcount(loc) == 1);
  uint8_t left = loc - 1;
  // Move enemies away from me by one and treat them as friends.
  friends |= (
    (enemies & left) >> 1
  ) | (
    (enemies & ~left) << 1
  );

  // Now we have 256 configurations of friends and 8 configurations of loc for a
  // total of 2048 -- easily cached in an array.

  // TODO: ideally we can reduce this to 64:
  // (idx(loc) - msb(obstaclesLeftOfLoc)) gives 8 values
  // (lsb(obstaclesRightOfLoc) - idx(loc)) gives 8 values

  return kSlideLookup[256 * lsb(loc) + friends];
}

constexpr Bitboard kKnightMoves[64] = {
  0x0000000000020400,
  0x0000000000050800,
  0x00000000000a1100,
  0x0000000000142200,
  0x0000000000284400,
  0x0000000000508800,
  0x0000000000a01000,
  0x0000000000402000,
  0x0000000002040004,
  0x0000000005080008,
  0x000000000a110011,
  0x0000000014220022,
  0x0000000028440044,
  0x0000000050880088,
  0x00000000a0100010,
  0x0000000040200020,
  0x0000000204000402,
  0x0000000508000805,
  0x0000000a1100110a,
  0x0000001422002214,
  0x0000002844004428,
  0x0000005088008850,
  0x000000a0100010a0,
  0x0000004020002040,
  0x0000020400040200,
  0x0000050800080500,
  0x00000a1100110a00,
  0x0000142200221400,
  0x0000284400442800,
  0x0000508800885000,
  0x0000a0100010a000,
  0x0000402000204000,
  0x0002040004020000,
  0x0005080008050000,
  0x000a1100110a0000,
  0x0014220022140000,
  0x0028440044280000,
  0x0050880088500000,
  0x00a0100010a00000,
  0x0040200020400000,
  0x0204000402000000,
  0x0508000805000000,
  0x0a1100110a000000,
  0x1422002214000000,
  0x2844004428000000,
  0x5088008850000000,
  0xa0100010a0000000,
  0x4020002040000000,
  0x0400040200000000,
  0x0800080500000000,
  0x1100110a00000000,
  0x2200221400000000,
  0x4400442800000000,
  0x8800885000000000,
  0x100010a000000000,
  0x2000204000000000,
  0x0004020000000000,
  0x0008050000000000,
  0x00110a0000000000,
  0x0022140000000000,
  0x0044280000000000,
  0x0088500000000000,
  0x0010a00000000000,
  0x0020400000000000,
};

constexpr Bitboard kKingMoves[64] = {
  0x0000000000000302,
  0x0000000000000705,
  0x0000000000000e0a,
  0x0000000000001c14,
  0x0000000000003828,
  0x0000000000007050,
  0x000000000000e0a0,
  0x000000000000c040,
  0x0000000000030203,
  0x0000000000070507,
  0x00000000000e0a0e,
  0x00000000001c141c,
  0x0000000000382838,
  0x0000000000705070,
  0x0000000000e0a0e0,
  0x0000000000c040c0,
  0x0000000003020300,
  0x0000000007050700,
  0x000000000e0a0e00,
  0x000000001c141c00,
  0x0000000038283800,
  0x0000000070507000,
  0x00000000e0a0e000,
  0x00000000c040c000,
  0x0000000302030000,
  0x0000000705070000,
  0x0000000e0a0e0000,
  0x0000001c141c0000,
  0x0000003828380000,
  0x0000007050700000,
  0x000000e0a0e00000,
  0x000000c040c00000,
  0x0000030203000000,
  0x0000070507000000,
  0x00000e0a0e000000,
  0x00001c141c000000,
  0x0000382838000000,
  0x0000705070000000,
  0x0000e0a0e0000000,
  0x0000c040c0000000,
  0x0003020300000000,
  0x0007050700000000,
  0x000e0a0e00000000,
  0x001c141c00000000,
  0x0038283800000000,
  0x0070507000000000,
  0x00e0a0e000000000,
  0x00c040c000000000,
  0x0302030000000000,
  0x0705070000000000,
  0x0e0a0e0000000000,
  0x1c141c0000000000,
  0x3828380000000000,
  0x7050700000000000,
  0xe0a0e00000000000,
  0xc040c00000000000,
  0x0203000000000000,
  0x0507000000000000,
  0x0a0e000000000000,
  0x141c000000000000,
  0x2838000000000000,
  0x5070000000000000,
  0xa0e0000000000000,
  0x40c0000000000000,
};

enum MoveGenType {
  CAPTURES = 1,
  QUIET_MOVES = 2,
  ALL_MOVES = 3,
};

/**
 * There's a cool idea in Stockfish to have a "target" bitboard.
 * Only moves that move to the target are returned. This way we
 * can ask only for moves that block a check and/or capture the checker.
 */

template<Color US, MoveGenType MGT>
ExtMove *compute_pawn_moves(const Position& pos, ExtMove *moves, Bitboard target) {
  constexpr Direction FORWARD = (US == Color::WHITE ? Direction::NORTH : Direction::SOUTH);
  constexpr Direction CAPTURE_DIR1 = Direction(FORWARD - 1);
  constexpr Direction CAPTURE_DIR2 = Direction(FORWARD + 1);

  constexpr ColoredPiece cp = coloredPiece<US, Piece::PAWN>();
  constexpr Bitboard rowInFrontOfHome = (US == Color::WHITE ? kRanks[5] : kRanks[2]);
  constexpr Bitboard promotionRow = (US == Color::WHITE ? kRanks[0] : kRanks[7]);

  Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  const Bitboard emptySquares = ~(pos.colorBitboards_[Color::BLACK] | pos.colorBitboards_[Color::WHITE]);
  const Location epLoc = square2location(pos.currentState_.epSquare);

  const Bitboard pawns = pos.pieceBitboards_[cp];

  Bitboard b1, b2, promoting;

  if (MGT & MoveGenType::QUIET_MOVES) {
    b1 = shift<FORWARD>(pawns) & emptySquares;
    b2 = shift<FORWARD>(b1 & rowInFrontOfHome) & emptySquares;

    b1 &= target;
    b2 &= target;

    promoting = b1 & promotionRow;
    b1 &= ~promoting;
    while (promoting) {
      Square to = pop_lsb(promoting);
      *moves++ = ExtMove(Piece::PAWN, Move{to - FORWARD, to, 0, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, Move{to - FORWARD, to, 1, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, Move{to - FORWARD, to, 2, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, Move{to - FORWARD, to, 3, MoveType::PROMOTION});
    }

    while (b1) {
      Square to = pop_lsb(b1);
      *moves++ = ExtMove(Piece::PAWN, Move{to - FORWARD, to, 0, MoveType::NORMAL});
    }
    while (b2) {
      Square to = pop_lsb(b2);
      *moves++ = ExtMove(Piece::PAWN, Move{to - FORWARD - FORWARD, to, 0, MoveType::NORMAL});
    }
  }

  if (MGT & MoveGenType::CAPTURES) {
    b1 = shift<CAPTURE_DIR1>(pawns) & (enemies | epLoc);
    b1 &= target;
    promoting = b1 & promotionRow;
    b1 &= ~promoting;
    while (promoting) {
      Square to = pop_lsb(promoting);
      Piece capture = cp2p(pos.tiles_[to]);
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR1, to, 0, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR1, to, 1, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR1, to, 2, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR1, to, 3, MoveType::PROMOTION});
    }
    while (b1) {
      Square to = pop_lsb(b1);
      Piece capture = cp2p(pos.tiles_[to]);
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR1, to, 0, MoveType::NORMAL});
    }

    b1 = shift<CAPTURE_DIR2>(pawns) & (enemies | epLoc);
    b1 &= target;
    promoting = b1 & promotionRow;
    b1 &= ~promoting;
    while (promoting) {
      Square to = pop_lsb(promoting);
      Piece capture = cp2p(pos.tiles_[to]);
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR2, to, 0, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR2, to, 1, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR2, to, 2, MoveType::PROMOTION});
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR2, to, 3, MoveType::PROMOTION});
    }
    while (b1) {
      Square to = pop_lsb(b1);
      Piece capture = cp2p(pos.tiles_[to]);
      *moves++ = ExtMove(Piece::PAWN, capture, Move{to - CAPTURE_DIR2, to, 0, MoveType::NORMAL});
    }
  }

  return moves;
}

template<Color US>
Bitboard compute_pawn_targets(const Position& pos) {
  constexpr ColoredPiece cp = coloredPiece<US, Piece::PAWN>();
  constexpr Direction FORWARD = (US == Color::WHITE ? Direction::NORTH : Direction::SOUTH);
  constexpr Direction CAPTURE_DIR1 = Direction(FORWARD - 1);
  constexpr Direction CAPTURE_DIR2 = Direction(FORWARD + 1);
  const Bitboard pawns = pos.pieceBitboards_[cp];
  return shift<CAPTURE_DIR1>(pawns) | shift<CAPTURE_DIR2>(pawns);
}

// TODO: test
template<Color US>
Bitboard compute_knight_targets(const Position& pos) {
  constexpr ColoredPiece cp = coloredPiece<US, Piece::KNIGHT>();
  const Bitboard knights = pos.pieceBitboards_[cp];
  Bitboard r = kEmptyBitboard;
  r |= (knights & ~(kFiles[0] | kRanks[0] | kRanks[1])) >> 17;
  r |= (knights & ~(kFiles[7] | kRanks[0] | kRanks[1])) >> 15;
  r |= (knights & ~(kFiles[0] | kFiles[1] | kRanks[0])) >> 10;
  r |= (knights & ~(kFiles[6] | kFiles[7] | kRanks[0])) >> 6;
  r |= (knights & ~(kFiles[0] | kFiles[1] | kRanks[7])) << 6;
  r |= (knights & ~(kFiles[6] | kFiles[7] | kRanks[7])) << 10;
  r |= (knights & ~(kFiles[0] | kRanks[6] | kRanks[7])) << 15;
  r |= (knights & ~(kFiles[7] | kRanks[6] | kRanks[7])) << 17;
  return r;
}

template<Color US>
Bitboard compute_bishoplike_targets(const Position& pos, Bitboard bishopLikePieces, const Bitboard occupied) {
  Bitboard r = kEmptyBitboard;

  while (bishopLikePieces) {
    const Square from = pop_lsb(bishopLikePieces);
    const Piece piece = cp2p(pos.tiles_[from]);
    Location fromLoc = square2location(from);
    const Bitboard southWestMask = diag::kSouthWestDiagonalMask[from];
    const Bitboard southEastMask = diag::kSouthEastDiagonalMask[from];

    {  // Southeast/Northwest diagonal.
      uint8_t enemiesByte = diag::southeast_diag_to_byte(from, occupied);
      uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
      r |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, 0, enemiesByte));
    }
    {  // Southwest/Northeast diagonal.
      uint8_t enemiesByte = diag::southwest_diag_to_byte(from, occupied);
      uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
      r |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, 0, enemiesByte));
    }

  }
  return r;
}

// TODO: test
template<Color US>
Bitboard compute_bishoplike_targets(const Position& pos, Bitboard bishopLikePieces) {
  const Bitboard occupied = (pos.colorBitboards_[US] | pos.colorBitboards_[opposite_color<US>()]) & ~bishopLikePieces;
  return compute_bishoplike_targets<US>(pos, bishopLikePieces, occupied);
}

template<Color US>
Bitboard compute_bishop_targets(const Position& pos, const Bitboard bishopLikePieces) {
  return compute_bishoplike_targets<US>(pos, pos.pieceBitboards_[coloredPiece<US, Piece::BISHOP>()]);
}

// TODO: test
template<Color US>
Bitboard compute_rooklike_targets(const Position& pos, Bitboard rookLikePieces, const Bitboard occupied) {
  Bitboard r = kEmptyBitboard;

  while (rookLikePieces) {
    const Square from = pop_lsb(rookLikePieces);
    const Location fromLoc = square2location(from);
    const unsigned y = from / 8;
    const unsigned x = from % 8;
    const Bitboard rank = kRanks[y];
    const Bitboard file = kFiles[x];

    Bitboard tos = kEmptyBitboard;

    {  // Compute east/west moves.
      const unsigned rankShift = y * 8;
      uint8_t fromByte = fromLoc >> rankShift;
      uint8_t enemiesByte = (occupied & rank) >> rankShift;
      r |= Bitboard(sliding_moves(fromByte, 0, enemiesByte)) << rankShift;
    }

    {  // Compute north/south moves.
      const unsigned columnShift = 7 - x;
      uint8_t fromByte = (((fromLoc << columnShift) & kFiles[7]) * kRookMagic) >> 56;
      uint8_t enemiesByte = (((occupied << columnShift) & kFiles[7]) * kRookMagic) >> 56;
      uint8_t toByte = sliding_moves(fromByte, 0, enemiesByte);
      r |= (((Bitboard(toByte & 254) * kRookMagic) & kFiles[0]) | (toByte & 1)) << x;
    }

  }

  return r;
}

template<Color US>
Bitboard compute_rooklike_targets(const Position& pos, Bitboard rookLikePieces) {
  const Bitboard occupied = (pos.colorBitboards_[US] | pos.colorBitboards_[opposite_color<US>()]) & ~rookLikePieces;
  return compute_rooklike_targets<US>(pos, rookLikePieces, occupied);
}


template<Color US>
Bitboard compute_rook_targets(const Position& pos, const Bitboard bishopLikePieces) {
  return compute_rooklike_targets<US>(pos, pos.pieceBitboards_[coloredPiece<US, Piece::ROOK>()]);
}

template<Color US, MoveGenType MGT>
ExtMove *compute_knight_moves(const Position& pos, ExtMove *moves, Bitboard target) {
  constexpr ColoredPiece cp = (US == Color::WHITE ? ColoredPiece::WHITE_KNIGHT : ColoredPiece::BLACK_KNIGHT);
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  const Bitboard notfriends = ~pos.colorBitboards_[US];
  Bitboard knights = pos.pieceBitboards_[cp];
  while (knights) {
    const Square from = pop_lsb(knights);
    Bitboard tos;
    if (MGT == MoveGenType::ALL_MOVES) {
      tos = kKnightMoves[from] & notfriends & target;
    } else if (MGT == MoveGenType::CAPTURES) {
      tos = kKnightMoves[from] & enemies & target;
    } else if (MGT == MoveGenType::QUIET_MOVES) {
      tos = kKnightMoves[from] & notfriends & ~enemies & target;
    }
    while (tos) {
      Square to = pop_lsb(tos);
      *moves++ = ExtMove(Piece::KNIGHT, cp2p(pos.tiles_[to]), Move{from, to, 0, MoveType::NORMAL});
    }
  }
  return moves;
}

// Absolutely required for castling.
// Also helps generate real moves (as opposed to pseudo-moves).
template<Color US>
bool can_enemy_attack(const Position& pos, Square sq) {
  return compute_enemy_attackers<US>(pos, sq) > 0;
}

// Returns which enemy pawns can attack the target.
template<Color US>
Bitboard compute_enemy_pawn_attackers(const Position& pos, const Bitboard target) {
  constexpr Color enemyColor = opposite_color<US>();
  constexpr Direction forward = (US == Color::WHITE ? Direction::NORTH : Direction::SOUTH);
  constexpr Direction pawnCaptureDir1 = Direction(forward - 1);
  constexpr Direction pawnCaptureDir2 = Direction(forward + 1);
  const Bitboard enemyPawns = pos.pieceBitboards_[coloredPiece<enemyColor, Piece::PAWN>()];
  return (shift<pawnCaptureDir1>(target) & enemyPawns) | (shift<pawnCaptureDir2>(target) & enemyPawns);
}

// 1 if any piece can get to a square.
// 0 if no piece can get to a square.
// Includes "self captures"
template<Color US>
Bitboard compute_my_targets(const Position& pos) {
  Bitboard r = compute_pawn_targets<US>(pos);
  r |= compute_knight_targets<US>(pos);
  const Bitboard bishopLikePieces = pos.pieceBitboards_[coloredPiece<US, Piece::BISHOP>()] | pos.pieceBitboards_[coloredPiece<US, Piece::QUEEN>()];
  r |= compute_bishoplike_targets<US>(pos, bishopLikePieces);
  const Bitboard rookLikePieces = pos.pieceBitboards_[coloredPiece<US, Piece::ROOK>()] | pos.pieceBitboards_[coloredPiece<US, Piece::QUEEN>()];
  r |= compute_rooklike_targets<US>(pos, rookLikePieces);
  r |= compute_king_targets<US>(pos);
  return r;
}

template<Color US>
Bitboard compute_enemy_attackers(const Position& pos, const Square sq) {
  constexpr Color enemyColor = opposite_color<US>();

  const Bitboard enemyRooks = pos.pieceBitboards_[coloredPiece<enemyColor, Piece::ROOK>()] | pos.pieceBitboards_[coloredPiece<enemyColor, Piece::QUEEN>()];
  const Bitboard enemyBishops = pos.pieceBitboards_[coloredPiece<enemyColor, Piece::BISHOP>()] | pos.pieceBitboards_[coloredPiece<enemyColor, Piece::QUEEN>()];

  const Location loc = square2location(sq);
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  const Bitboard friends = pos.colorBitboards_[US] & ~loc;

  const Bitboard file = kFiles[sq % 8];
  const Bitboard rank = kRanks[sq / 8];

  Bitboard attackers = kEmptyBitboard;
  attackers |= (kKnightMoves[sq] & pos.pieceBitboards_[coloredPiece<enemyColor, Piece::KNIGHT>()]);
  attackers |= (kKingMoves[sq] & pos.pieceBitboards_[coloredPiece<enemyColor, Piece::KING>()]);

  attackers |= compute_enemy_pawn_attackers<US>(pos, loc);

  // TODO: complete this for sliding pieces.

  {  // Compute east/west moves.
    const uint8_t y = sq / 8;
    const unsigned rankShift = y * 8;
    uint8_t fromByte = loc >> rankShift;
    uint8_t enemiesByte = (enemies | friends) >> rankShift;
    uint8_t toByte = sliding_moves(fromByte, 0, enemiesByte);
    Bitboard to = Bitboard(toByte) << rankShift;
    attackers |= ((to & enemyRooks) > 0);
  }

  {  // North/south attackers
    const uint8_t x = (sq % 8);
    const unsigned columnShift = 7 - x;
    uint8_t fromByte = (((loc << columnShift) & kFiles[7]) * kRookMagic) >> 56;
    uint8_t enemiesByte = (((((enemies | friends) & file) << columnShift) & kFiles[7]) * kRookMagic) >> 56;
    uint8_t toByte = sliding_moves(fromByte, 0, enemiesByte);
    Bitboard to = (((Bitboard(toByte & 254) * kRookMagic) & kFiles[0]) | (toByte & 1)) << x;
    attackers |= ((to & enemyRooks) > 0);
  }

  {  // Southeast/Northwest diagonal.
    uint8_t enemiesByte = diag::southeast_diag_to_byte(sq, enemies | friends);
    uint8_t fromByte = diag::southeast_diag_to_byte(sq, loc);
    Bitboard to = diag::byte_to_southeast_diag(sq, sliding_moves(fromByte, 0, enemiesByte));
    attackers |= ((to & enemyBishops) > 0);
  }
  {  // Southwest/Northeast diagonal.
    uint8_t enemiesByte = diag::southwest_diag_to_byte(sq, enemies | friends);
    uint8_t fromByte = diag::southwest_diag_to_byte(sq, loc);
    Bitboard to = diag::byte_to_southwest_diag(sq, sliding_moves(fromByte, 0, enemiesByte));
    attackers |= ((to & enemyBishops) > 0);
  }

  return attackers;
}

template<Color US>
Bitboard compute_king_targets(const Position& pos) {
  return kKingMoves[lsb(pos.pieceBitboards_[coloredPiece<US, Piece::KING>()])];
}

template<Color US, MoveGenType MGT, bool inCheck>
ExtMove *compute_king_moves(const Position& pos, ExtMove *moves, Bitboard target) {
  constexpr ColoredPiece cp = (US == Color::WHITE ? ColoredPiece::WHITE_KING : ColoredPiece::BLACK_KING);
  const Bitboard notfriends = ~pos.colorBitboards_[US];
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  const Bitboard allPieces = pos.colorBitboards_[Color::WHITE] | pos.colorBitboards_[Color::BLACK];
  Bitboard kings = pos.pieceBitboards_[cp];
  while (kings) {
    const Square from = pop_lsb(kings);
    Bitboard tos;
    if (MGT == MoveGenType::ALL_MOVES) {
      tos = kKingMoves[from] & notfriends & target;
    } else if (MGT == MoveGenType::CAPTURES) {
      tos = kKingMoves[from] & enemies & target;
    } else if (MGT == MoveGenType::QUIET_MOVES) {
      tos = kKingMoves[from] & notfriends & ~enemies & target;
    }
    while (tos) {
      Square to = pop_lsb(tos);
      *moves++ = ExtMove(Piece::KING, cp2p(pos.tiles_[to]), Move{from, to, 0, MoveType::NORMAL});
    }
  }

  if (MGT & MoveGenType::QUIET_MOVES) {
    CastlingRights cr = pos.currentState_.castlingRights;
    if (!inCheck) {
      if (US == Color::WHITE) {
        if (!inCheck
          && ((allPieces & (bb(62) | bb(61))) == 0)
          && (cr & kCastlingRights_WhiteKing)
          && !can_enemy_attack<US>(pos, Square::F1)
          && !can_enemy_attack<US>(pos, Square::G1)
          && (target & bb(Square::G1))) {
          *moves++ = ExtMove(Piece::KING, Piece::NO_PIECE, Move{Square::E1, Square::G1, 0, MoveType::CASTLE});
        }
        if (!inCheck
          && ((allPieces & (bb(59) | bb(58) | bb(57))) == 0)
          && (cr & kCastlingRights_WhiteQueen)
          && !can_enemy_attack<US>(pos, Square::D1)
          && !can_enemy_attack<US>(pos, Square::C1)
          && (target & bb(Square::C1))) {
          *moves++ = ExtMove(Piece::KING, Piece::NO_PIECE, Move{Square::E1, Square::C1, 0, MoveType::CASTLE});
        }
      } else {
        if (((allPieces & (bb(5) | bb(6))) == 0)
          && (cr & kCastlingRights_BlackKing)
          && !can_enemy_attack<US>(pos, Square(5))
          && !can_enemy_attack<US>(pos, Square(6))
          && (target & bb(6))) {
          *moves++ = ExtMove(Piece::KING, Piece::NO_PIECE, Move{Square::E8, Square(6), 0, MoveType::CASTLE});
        }
        if (((allPieces & (bb(1) | bb(2) | bb(3))) == 0)
          && (cr & kCastlingRights_BlackQueen)
          && !can_enemy_attack<US>(pos, Square(2))
          && !can_enemy_attack<US>(pos, Square(3))
          && (target & bb(2))) {
          *moves++ = ExtMove(Piece::KING, Piece::NO_PIECE, Move{Square::E8, Square(2), 0, MoveType::CASTLE});
        }
      }
    }
  }

  return moves;
}

// Computes moves for rook and rook-like moves for queen.
template<Color US, MoveGenType MGT>
ExtMove *compute_rook_like_moves(const Position& pos, ExtMove *moves, Bitboard target) {
  constexpr ColoredPiece myRookPiece = (US == Color::WHITE ? ColoredPiece::WHITE_ROOK : ColoredPiece::BLACK_ROOK);
  constexpr ColoredPiece myQueenPiece = (US == Color::WHITE ? ColoredPiece::WHITE_QUEEN : ColoredPiece::BLACK_QUEEN);
  const Bitboard friends = pos.colorBitboards_[US];
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  Bitboard rookLikePieces = pos.pieceBitboards_[myRookPiece] | pos.pieceBitboards_[myQueenPiece];
  while (rookLikePieces) {
    const Square from = pop_lsb(rookLikePieces);
    const Piece piece = cp2p(pos.tiles_[from]);
    Location fromLoc = square2location(from);
    const unsigned y = from / 8;
    const unsigned x = from % 8;
    const Bitboard rank = kRanks[y];
    const Bitboard file = kFiles[x];

    Bitboard tos = kEmptyBitboard;

    {  // Compute east/west moves.
      const unsigned rankShift = y * 8;
      uint8_t fromByte = fromLoc >> rankShift;
      uint8_t friendsByte = (friends & ~fromLoc & rank) >> rankShift;
      uint8_t enemiesByte = (enemies & rank) >> rankShift;

      tos |= Bitboard(sliding_moves(fromByte, friendsByte, enemiesByte)) << rankShift;
    }

    {  // Compute north/south moves.
      const unsigned columnShift = 7 - x;
      uint8_t fromByte = (((fromLoc << columnShift) & kFiles[7]) * kRookMagic) >> 56;
      uint8_t friendsByte = ((((friends & ~fromLoc) << columnShift) & kFiles[7]) * kRookMagic) >> 56;
      uint8_t enemiesByte = (((enemies << columnShift) & kFiles[7]) * kRookMagic) >> 56;
      uint8_t toByte = sliding_moves(fromByte, friendsByte, enemiesByte);
      tos |= (((Bitboard(toByte & 254) * kRookMagic) & kFiles[0]) | (toByte & 1)) << x;
    }

    if (MGT == MoveGenType::CAPTURES) {
      tos &= enemies;
    } else if (MGT == MoveGenType::QUIET_MOVES) {
      tos &= ~enemies;
    }

    tos &= target;

    while (tos) {
      Square to = pop_lsb(tos);
      *moves++ = ExtMove(piece, cp2p(pos.tiles_[to]), Move{from, to, 0, MoveType::NORMAL});
    }

  }
  return moves;
}

template<Color US, MoveGenType MGT>
ExtMove *compute_bishop_like_moves(const Position& pos, ExtMove *moves, Bitboard target) {
  constexpr ColoredPiece myBishopPiece = (US == Color::WHITE ? ColoredPiece::WHITE_BISHOP : ColoredPiece::BLACK_BISHOP);
  constexpr ColoredPiece myQueenPiece = (US == Color::WHITE ? ColoredPiece::WHITE_QUEEN : ColoredPiece::BLACK_QUEEN);
  const Bitboard friends = pos.colorBitboards_[US];
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  Bitboard bishopLikePieces = pos.pieceBitboards_[myBishopPiece] | pos.pieceBitboards_[myQueenPiece];

  while (bishopLikePieces) {
    const Square from = pop_lsb(bishopLikePieces);
    const Piece piece = cp2p(pos.tiles_[from]);
    Location fromLoc = square2location(from);
    const Bitboard southWestMask = diag::kSouthWestDiagonalMask[from];
    const Bitboard southEastMask = diag::kSouthEastDiagonalMask[from];

    Bitboard tos = kEmptyBitboard;

    {  // Southeast/Northwest diagonal.
      uint8_t friendsByte = diag::southeast_diag_to_byte(from, friends & ~fromLoc);
      uint8_t enemiesByte = diag::southeast_diag_to_byte(from, enemies);
      uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
      tos |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, friendsByte, enemiesByte));
    }
    {  // Southwest/Northeast diagonal.
      uint8_t friendsByte = diag::southwest_diag_to_byte(from, friends & ~fromLoc);
      uint8_t enemiesByte = diag::southwest_diag_to_byte(from, enemies);
      uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
      tos |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, friendsByte, enemiesByte));
    }

    if (MGT == MoveGenType::CAPTURES) {
      tos &= enemies;
    } else if (MGT == MoveGenType::QUIET_MOVES) {
      tos &= ~enemies;
    }

    while (tos) {
      Square to = pop_lsb(tos);
      *moves++ = ExtMove(piece, cp2p(pos.tiles_[to]), Move{from, to, 0, MoveType::NORMAL});
    }
  }

  return moves;
}

template<Color US, MoveGenType MGT>
ExtMove* compute_moves(const Position& pos, ExtMove *moves) {
  assert(US == pos.turn_);
  const Bitboard ourKings = pos.pieceBitboards_[coloredPiece<US, Piece::KING>()];
  const Bitboard theirKings = pos.pieceBitboards_[coloredPiece<opposite_color<US>(), Piece::KING>()];
  if (std::popcount(ourKings | theirKings) != 2) {
    // Game over, no legal moves.
    return moves;
  }
  const Square ourKing = lsb(ourKings);
  Bitboard checkers = compute_enemy_attackers<US>(pos, ourKing);

  const unsigned numCheckers = std::popcount(checkers);

  if (numCheckers > 1) {  // Double check; king must move.
    return compute_king_moves<US, MGT, true>(pos, moves, kUniverse);
  }

  Bitboard target = kUniverse;
  if (numCheckers == 1) {
    // TODO
  }

  moves = compute_pawn_moves<US, MGT>(pos, moves, target);
  moves = compute_knight_moves<US, MGT>(pos, moves, target);
  if (numCheckers > 0) {
    moves = compute_king_moves<US, MGT, true>(pos, moves, kUniverse);
  } else {
    moves = compute_king_moves<US, MGT, false>(pos, moves, kUniverse);
  }
  moves = compute_bishop_like_moves<US, MGT>(pos, moves, target);
  moves = compute_rook_like_moves<US, MGT>(pos, moves, target);
  return moves;
}

template<Color US>
ExtMove* compute_legal_moves(Position *pos, ExtMove *moves) {
  ExtMove pseudoMoves[kMaxNumMoves];
  ExtMove *end = compute_moves<US, MoveGenType::ALL_MOVES>(*pos, pseudoMoves);
  for (ExtMove *move = pseudoMoves; move < end; ++move) {
    make_move<US>(pos, move->move);
    Square sq = lsb(pos->pieceBitboards_[coloredPiece<US,Piece::KING>()]);
    if (can_enemy_attack<US>(*pos, sq) == 0) {
      (*moves++) = *move;
    }
    undo<US>(pos);
  }
  return moves;
}

}  // namespace ChessEngine

#endif  // MOVEGEN_H