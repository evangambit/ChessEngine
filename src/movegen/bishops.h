#ifndef MOVEGEN_BISHOPS_H
#define MOVEGEN_BISHOPS_H

#include "../Position.h"
#include "../utils.h"
#include "sliding.h"

namespace ChessEngine {

namespace diag {

// For a given square, get all points along its southwest/northeast diagonal.
constexpr Bitboard kSouthWestDiagonalMask[64] = {
  0x1,
  0x102,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x102,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x4080000000000000,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x4080000000000000,
  0x8000000000000000,
};

constexpr Bitboard kMainDiagonals = 0x8040201008040201 | 0x102040810204080;

// For a given square, get all points along its southeast/northwest diagonal.
constexpr Bitboard kSouthEastDiagonalMask[64] = {
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x8040,
  0x80,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x8040,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x201000000000000,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x100000000000000,
  0x201000000000000,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
};

const uint64_t kSouthEastShift[64] = {
  0, 1, 2, 3, 4, 5, 6, 7,
  0, 0, 1, 2, 3, 4, 5, 6,
  0, 0, 0, 1, 2, 3, 4, 5,
  0, 0, 0, 0, 1, 2, 3, 4,
  0, 0, 0, 0, 0, 1, 2, 3,
  0, 0, 0, 0, 0, 0, 1, 2,
  0, 0, 0, 0, 0, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
};

const uint64_t kSouthWestShift[64] = {
  7, 6, 5, 4, 3, 2, 1, 0,
  6, 5, 4, 3, 2, 1, 0, 0,
  5, 4, 3, 2, 1, 0, 0, 0,
  4, 3, 2, 1, 0, 0, 0, 0,
  3, 2, 1, 0, 0, 0, 0, 0,
  2, 1, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
};

// After calling "southeast_diag_to_byte", this array indicates
// which bits in the byte are off the board (and hence invalid to move to).
// Generated by
//
// for (int i = 0; i < 64; ++i) {
//   uint8_t byte = ~diag::southeast_diag_to_byte(Square(i), kUniverse);
//   std::cout << "0x" << std::hex << unsigned(byte) << ", ";
//   if (i % 8 == 7) {
//     std::cout << std::endl;
//   }
// }
const uint8_t kSouthEastOffBoard[64] = {
  0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe,
  0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc,
  0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8,
  0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0,
  0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0,
  0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0,
  0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80,
  0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0,
};

const uint8_t kSouthWestOffBoard[64] = {
  0x7f, 0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0,
  0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0, 0x1,
  0x1f, 0xf, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3,
  0xf, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7,
  0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xf,
  0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f,
  0x1, 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f,
  0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f,
};

constexpr Bitboard kBishopMagic = bb(56) | bb(48) | bb(40) | bb(32) | bb(24) | bb(16) | bb(8) | bb(0);

uint8_t southeast_diag_to_byte(Square sq, Bitboard b) {
  b &= kSouthEastDiagonalMask[sq];
  b >>= kSouthEastShift[sq];
  return (b * kBishopMagic) >> 56;
}

uint8_t southwest_diag_to_byte(Square sq, Bitboard b) {
  b &= kSouthWestDiagonalMask[sq];
  b <<= kSouthWestShift[sq];
  return (b * kBishopMagic) >> 56;
}

Bitboard byte_to_southeast_diag(Square sq, Bitboard byte) {
  assert(byte < 256);
  byte *= kBishopMagic;
  byte <<= diag::kSouthEastShift[sq];
  byte &= kSouthEastDiagonalMask[sq];
  return byte;
}

Bitboard byte_to_southwest_diag(Square sq, Bitboard byte) {
  assert(byte < 256);
  byte *= kBishopMagic;
  byte >>= diag::kSouthWestShift[sq];
  byte &= kSouthWestDiagonalMask[sq];
  return byte;
}

}  // namespace diag

template<Color US>
Bitboard compute_bishoplike_targets(const Position& pos, Bitboard bishopLikePieces, const Bitboard occupied) {
  Bitboard r = kEmptyBitboard;

  while (bishopLikePieces) {
    const Square from = pop_lsb(bishopLikePieces);
    const Piece piece = cp2p(pos.tiles_[from]);
    Location fromLoc = square2location(from);
    const Bitboard southWestMask = diag::kSouthWestDiagonalMask[from];
    const Bitboard southEastMask = diag::kSouthEastDiagonalMask[from];

    {  // Southeast/Northwest diagonal.
      uint8_t enemiesByte = diag::southeast_diag_to_byte(from, occupied);
      uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
      r |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, 0, enemiesByte));
    }
    {  // Southwest/Northeast diagonal.
      uint8_t enemiesByte = diag::southwest_diag_to_byte(from, occupied);
      uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
      r |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, 0, enemiesByte));
    }

  }
  return r;
}

template<Color US>
Bitboard compute_bishoplike_targets(const Position& pos, Bitboard bishopLikePieces) {
  const Bitboard occupied = (pos.colorBitboards_[US] | pos.colorBitboards_[opposite_color<US>()]) & ~bishopLikePieces;
  return compute_bishoplike_targets<US>(pos, bishopLikePieces, occupied);
}

template<Color US>
Bitboard compute_bishop_targets(const Position& pos, const Bitboard bishopLikePieces) {
  return compute_bishoplike_targets<US>(pos, pos.pieceBitboards_[coloredPiece<US, Piece::BISHOP>()]);
}

template<Color US, MoveGenType MGT>
ExtMove *compute_bishop_like_moves(const Position& pos, ExtMove *moves, Bitboard target) {
  constexpr ColoredPiece myBishopPiece = (US == Color::WHITE ? ColoredPiece::WHITE_BISHOP : ColoredPiece::BLACK_BISHOP);
  constexpr ColoredPiece myQueenPiece = (US == Color::WHITE ? ColoredPiece::WHITE_QUEEN : ColoredPiece::BLACK_QUEEN);
  const Bitboard friends = pos.colorBitboards_[US];
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  Bitboard bishopLikePieces = pos.pieceBitboards_[myBishopPiece] | pos.pieceBitboards_[myQueenPiece];

  Bitboard checkMask;
  if (MGT == MoveGenType::CHECKS_AND_CAPTURES) {
    checkMask = kEmptyBitboard;
    const Bitboard enemyKing = pos.pieceBitboards_[coloredPiece<opposite_color<US>(), Piece::KING>()];
    const Square enemyKingSq = lsb(enemyKing);
    {  // Southeast/Northwest diagonal.
      uint8_t occupied = diag::southeast_diag_to_byte(enemyKingSq, friends | enemies & ~enemyKing);
      uint8_t fromByte = diag::southeast_diag_to_byte(enemyKingSq, enemyKing);
      checkMask |= diag::byte_to_southeast_diag(enemyKingSq, sliding_moves(fromByte, 0, occupied));
    }
    {  // Southwest/Northeast diagonal.
      uint8_t occupied = diag::southwest_diag_to_byte(enemyKingSq, friends | enemies & ~enemyKing);
      uint8_t fromByte = diag::southwest_diag_to_byte(enemyKingSq, enemyKing);
      checkMask |= diag::byte_to_southwest_diag(enemyKingSq, sliding_moves(fromByte, 0, occupied));
    }
  } else {
    checkMask = kUniverse;
  }

  while (bishopLikePieces) {
    const Square from = pop_lsb(bishopLikePieces);
    const Piece piece = cp2p(pos.tiles_[from]);
    Location fromLoc = square2location(from);
    const Bitboard southWestMask = diag::kSouthWestDiagonalMask[from];
    const Bitboard southEastMask = diag::kSouthEastDiagonalMask[from];

    Bitboard tos = kEmptyBitboard;

    {  // Southeast/Northwest diagonal.
      uint8_t friendsByte = diag::southeast_diag_to_byte(from, friends & ~fromLoc);
      uint8_t enemiesByte = diag::southeast_diag_to_byte(from, enemies);
      uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
      tos |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, friendsByte, enemiesByte));
    }
    {  // Southwest/Northeast diagonal.
      uint8_t friendsByte = diag::southwest_diag_to_byte(from, friends & ~fromLoc);
      uint8_t enemiesByte = diag::southwest_diag_to_byte(from, enemies);
      uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
      tos |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, friendsByte, enemiesByte));
    }

    tos &= target;

    if (MGT == MoveGenType::ALL_MOVES) {
      // no-op
    }
    else if (MGT == MoveGenType::CAPTURES) {
      tos &= enemies;
    }
    else if (MGT == MoveGenType::CHECKS_AND_CAPTURES) {
      tos &= enemies | checkMask;
    }

    while (tos) {
      Square to = pop_lsb(tos);
      *moves++ = ExtMove(piece, cp2p(pos.tiles_[to]), Move{from, to, 0, MoveType::NORMAL});
    }
  }

  return moves;
}

}  // namespace ChessEngine

#endif  // MOVEGEN_BISHOPS_H
